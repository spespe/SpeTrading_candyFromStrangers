#Pietro Speri - 05-04-2018


extern string __s2 = "-----  SL/PT Parameters  ----------------------";
extern double MinimumSLPT = 30;
extern double MaximumSLPT = 300;

extern string __s6 = "-----  Money Management -----------";
extern bool UseMoneyManagement = false;
extern double Lots = 0.1;
extern int LotsDecimals = 2;
extern double RiskInPercent = 2.0;
extern double MaximumLots = 0.5;
extern bool UseFixedMoney = false;
extern double RiskInMoney = 100.0;

extern string __s7 = "-----  Settings  ----------------";
extern int MaxTradesPerDay = 0; // 0 means unlimited
extern bool LimitSignalsToRange = false;
extern string TimeRangeFrom = "08:00";
extern string TimeRangeTo = "16:00";
extern bool ExitAtEndOfRange = false;
extern bool ExitAtEndOfDay = false;
extern string ExitTimeEOD = "00:00";
extern bool ExitOnFriday = true;
extern string ExitTimeOnFriday = "00:00";

extern bool TradeLong = true;
extern bool TradeShort = true;


extern string __s8 = "-----  Trading Date Parameters  ---------------";
extern bool TradeSunday = true;
extern bool TradeMonday = true;
extern bool TradeTuesday = true;
extern bool TradeWednesday = true;
extern bool TradeThursday = true;
extern bool TradeFriday = true;
extern bool TradeSaturday = true;

extern string __s9 = "-----  Other Parameters  ----------------------";
extern int MaxSlippage = 3;
extern string CustomComment = "Strategy 2.127";
extern int MagicNumber = 12345;
extern bool EmailNotificationOnTrade = false;
extern bool DisplayInfoPanel = true;

//Hidden
int MinDistanceOfStopFromPrice = 5.0;
double gPointPow = 0;
double gPointCoef = 0;
double gbSpread = 3.0;
double brokerStopDifference = 0;
string eaStopDifference = "";
double eaStopDifferenceNumber = 0;
int lastHistoryPosChecked = 0;
int lastHistoryPosCheckedNT = 0;
string currentTime = "";
string lastTime = "";
bool tradingRangeReverted = false;
string sqLastPeriod;
bool sqIsBarOpen;
int LabelCorner = 1;
int OffsetHorizontal = 5;
int OffsetVertical = 20;
color LabelColor = White;
int lastDeletedOrderTicket = -1;

bool checkTradeClosedCurrent() {
   int startAt = lastHistoryPosChecked-10;
   if(startAt < 0) {
      startAt = 0;
   }

   for(int i=startAt;i<OrdersHistoryTotal();i++) {
      if(OrderSelect(i,SELECT_BY_POS,MODE_HISTORY)==true && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol()) {
         if((OrderType() == OP_BUY || OrderType() == OP_SELL) && OrderCloseTime() >= Time[0]) {
            return(true);
         }
      }
   }

   return(false);
}


double gbTrueRange(int period, int index) {
   int period1 = period + index-1;
   int period2 = period + index;
   return (MathMax(High[period1], Close[period2]) - MathMin(Low[period1], Close[period2]));
}

double gbBarRange(int period, int index) {
   int period2 = period + index-1;
   return (MathAbs(High[period2] - Low[period2]));
}


//Custom start method
bool customStart() {
   return(true);
}

double computeMM(double riskPerTrade, double slSize) {
   if(slSize <= 0) {
      Log("Incorrect StopLossPips size, it must be above 0");
      return(0);
   }

   // adjust money management for non-US currencies
   double CurrencyAdjuster=1;
   if (MarketInfo(Symbol(),MODE_TICKSIZE)!=0) CurrencyAdjuster=MarketInfo(Symbol(),MODE_TICKVALUE) * (MarketInfo(Symbol(),MODE_POINT) / MarketInfo(Symbol(),MODE_TICKSIZE));

   double lotMM1 = NormalizeDouble(riskPerTrade / CurrencyAdjuster / (slSize * 10.0), LotsDecimals);
   double lotMM;
   double lotStep = MarketInfo(Symbol(), MODE_LOTSTEP);
   if(MathMod(lotMM*100, lotStep*100) > 0) {
      lotMM = lotMM1 - MathMod(lotMM1, lotStep);
   } else {
      lotMM = lotMM1;
   }

   lotMM = NormalizeDouble( lotMM, LotsDecimals);

   if(MarketInfo(Symbol(), MODE_LOTSIZE)==10000.0) lotMM=lotMM*10.0 ;
   lotMM=NormalizeDouble(lotMM,LotsDecimals);

   //Log("Computing lots, risk: ", riskPerTrade, ", lotMM1: ", lotMM1, ", lotStep: ", lotStep, ", lots: ", lotMM);
   double Smallest_Lot = MarketInfo(Symbol(), MODE_MINLOT);
   double Largest_Lot = MarketInfo(Symbol(), MODE_MAXLOT);

   if (lotMM < Smallest_Lot) lotMM = Smallest_Lot;
   if (lotMM > Largest_Lot) lotMM = Largest_Lot;

   if(lotMM > MaximumLots) {
      lotMM = MaximumLots;
   }

   //Log("SL size: ", slSize, ", LotMM: ", lotMM);

   return (lotMM);
}


//Risk perc method
double getRiskPerc(double slSize) {
   if(RiskInPercent <0 ) {
      Log("Incorrect risk size");
      return(0);
   }

   double riskPerTrade = (AccountBalance() *  (RiskInPercent / 100.0));
   return(computeMM(riskPerTrade, slSize)); // to be created
}

//Rules methods
bool CloseAboveBB() {
   return (Close[1] > iBands(NULL,0, 20, 2, 0, PRICE_CLOSE, MODE_UPPER, 1)) ;
}

bool CloseBelowBB() {
   return (Close[1] < iBands(NULL,0, 20, 2, 0, PRICE_CLOSE, MODE_LOWER, 1)) ;
}

bool CloseAbovePSAR() {
   return (Close[1] > iSAR(NULL,0, 0.02, 0.2, 1)) ;
}

bool CloseBelowPSAR() {
   return (Close[1] < iSAR(NULL,0, 0.02, 0.2, 1)) ;
}

bool MACD_Above() {
   return (iMACD(NULL,0, 12, 26, 9, PRICE_CLOSE, MODE_MAIN, 1) > 0) ;
}

bool MACD_Below() {
   return (iMACD(NULL,0, 12, 26, 9, PRICE_CLOSE, MODE_MAIN, 1) < 0) ;
}

bool LongTermRSI_Above() {
   return (iRSI(NULL,0,40,PRICE_CLOSE,1) > 50) ;
}

bool LongTermRSI_Below() {
   return (iRSI(NULL,0,40,PRICE_CLOSE,1) < 50) ;
}

bool ShortTermRSI_Above() {
   return (iRSI(NULL,0,20,PRICE_CLOSE,1) > 50) ;
}

bool ShortTermRSI_Below() {
   return (iRSI(NULL,0,20,PRICE_CLOSE,1) < 50) ;
}


bool LongTermStoch_Above() {
   return (iStochastic(NULL,0, 40, 1, 3, MODE_SMA, 0, 1, 1) > 50) ;
}

bool LongTermStoch_Below() {
   return (iStochastic(NULL,0, 40, 1, 3, MODE_SMA, 0, 1, 1) < 50) ;
}

bool ShortTermStoch_Above() {
   return (iStochastic(NULL,0, 20, 1, 3, MODE_SMA, 0, 1, 1) > 50) ;
}

bool ShortTermStoch_Below() {
   return (iStochastic(NULL,0, 20, 1, 3, MODE_SMA, 0, 1, 1) < 50) ;
}

bool LongTermCCI_Above() {
   return (iCCI(NULL,0,40,PRICE_TYPICAL,1) > 0) ;
}

bool LongTermCCI_Below() {
   return (iCCI(NULL,0,40,PRICE_TYPICAL,1) < 0) ;
}

bool ShortTermCCI_Above() {
   return (iCCI(NULL,0,20,PRICE_TYPICAL,1) > 0) ;
}

bool ShortTermCCI_Below() {
   return (iCCI(NULL,0,20,PRICE_TYPICAL,1) < 0) ;
}

bool ruleVolumeAboveAvg() {
   return (Volume[1] > iCustom(NULL,0, "AvgVolume", 50, 1, 1)) ;
}

bool ruleVolumeBelowAvg() {
   return (Volume[1] < iCustom(NULL,0, "AvgVolume", 50, 1, 1)) ;
}

//Candle patterns
bool BearishEngulfing(int s) {
   double O = Open[s];
   double O1 = Open[s+1];
   double C = Close[s];
   double C1 = Close[s+1];

   if ((C1>O1)&&(O>C)&&(O>=C1)&&(O1>=C)&&((O-C)>(C1-O1))) {
      return(true);
   }

   return(false);
}
